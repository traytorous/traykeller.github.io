---
title: First Post
published: true
---
<h2>Plans</h2>

<p>My plans for the next 3 weeks that I have off from school is to better understand binary exploiation and exploitation in general by reading, doing ctfs, and doing side projects as well. This is Day 1 of my Journey. I may not do this every day but I will definetly try.</p>
<hr />
<h2><strong><span style="text-decoration:underline;">DAY 1</span></strong></h2>
<p>It&#8217;s 3 am and I can&#8217;t stop researching more about exploitation in general. I feel very accomplished today. I&#8217;ve researched more on memory management and how the operating system&#8217;s kernel manages memory. I also got a good overview of the differences between kernel space exploitation vs User space exploitation. I&#8217;m gonna try and post every day to show my progress and for me to keep track of what I&#8217;ve done. After I post this I shall be doing more practice doing micro corruption to see if it helps me understanding assembly better. Tomorrow I shall keep reading on these subjects and also code a side project in C. Something Small so that I can get more familiar with pointers. Also, I need to learn how to use gdb and radare2 better.</p>
<h2><span style="text-decoration:underline;">NOTES</span></h2>
<hr />
<p>Binary exploiation Day 1<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
<p>BOOK = KERNEL EXPLOITATION<br />
An exploit that works on only a specific scenario or that just crashes the appli-<br />
cation is of little use. This so-called proof of concept (PoC) is basically an<br />
unfinished piece of work, usually written quickly and only to demonstrate the<br />
vulnerability.</p>
<ul>
<li><span style="text-decoration:underline;">Local exploit</span> means you have to have access to the machine, while remote exploit is an attack that can be used through a network<br />
Dissecting a generic exploit 3 main components<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
*Preparatory phase &#8211; information about the target is gathered and a favorable enviorment is set up<br />
*Shellcode &#8211; this is a sequence of machine level instructions that, when excuted usually lead to an elevatoin of privleges<br />
*triggering &#8211; the shellcode is placed inside the memory of the target process(and the vulnerablity redirects the program to the shellcode<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
Nop are just good no operation code that does nothing and that leads up to the shell code</li>
<li>All modern operating systems have a NOP instruction that exploit writers use to direct cpu controll</li>
<li>Memory is very complicated. if a program is a 64 bit program that means that it can access any 64 bit address space. Virtual memory is pretty much just fancy rediraction<br />
It also stops memory fragmentation<br />
look up more on page tables and virtual memory<br />
a different page table is created for each process</li>
</ul>
<p>&nbsp;</p>
<p>BOOK = SHELLCODERS HANDBOOK<br />
<span style="text-decoration:underline;">There are different sections in memory</span><br />
.text, .data, .bss<br />
then there is the stack and the heap which are structures in memory. The stack grows down in memory while the heap grows up so that it can take up the most neccesary amount of space</p>
<ul>
<li>There are 3 types of registers<br />
General purpose &#8211; Doing math operations on them(EAX and the rest) Also the ESP register points the memory address of the stack<br />
Segment registers &#8211; No IDEA (LOOK INTO MORE)<br />
Pointer registers &#8211; are registers that are given the instructions to tell the cpu what to do (YOU KNOW THIS ONE WELL EIP)<br />
Buffer is just contiuous memory that is set(you know this but for context later)</li>
</ul>
<p>RESOURCES FOR MEMORY MANAGEMENT -&gt; <a href="https://linux-mm.org/LinuxMMDocumentation" rel="nofollow">https://linux-mm.org/LinuxMMDocumentation</a></p>
<p>&nbsp;</p>
<p>End of research for today</p>
<p>Thanks for reading and sorry for how messy the notes are ðŸ™‚</p>
